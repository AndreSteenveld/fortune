# Architecture

This document explains the inner workings of Fortune.


## Adapter

The adapter does not provide ORM-like capabilities, it is just a means to get objects into and out of a data store. The objects it deals with are just plain objects with no methods attached. It is more aligned to a functional style rather than object-oriented.

There is an important global concept of primary key, which Fortune relies on and is a **MUST** to implement. Every object returned by the adapter must have a primary key, which by default is `id` but can be configured to any arbitrary name. The primary key can only be generated by Fortune, which may be arbitrarily defined as long as it is not null and unique. Serializers may transform this primary key to clients, so the primary key configuration may not necessarily reflect what a client sees.

There are stub methods to start and end a transaction, which are optional to implement but highly recommended for ACID transactions.

The responsibility of the `init` method is to ensure that the resources defined are consistent with the backing data store. For relational databases this means tables either exist or are created, schemas exist or are created, and if there is any mismatch it should fail. At that point the differences between the application and the database should be reconciled.


## Serializer

Serializers parse and render external input and output. The input parsing methods accept the `context` and should return arrays of objects, while the output rendering methods accept arrays of objects and should mutate the `context`. The schema is enforced before parsing and after rendering, so that types from input to output will be consistent.


## Dispatcher

This is the central workflow. The dispatcher passes data to the next handler in a request lifecycle, using the `context` object through its internal methods. The internal methods mutate the `context` until the end of the request is reached, and returns the `response` part of the `context`.

Schema enforcement happens here, types are casted before `before` transforms and after `after` transforms, so that types should be consistent with the schema.
