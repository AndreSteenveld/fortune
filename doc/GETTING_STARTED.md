# Getting Started

Fortune provides generic features (mostly [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) and [serialization](https://en.wikipedia.org/wiki/Serialization)) intended to be used in web applications, or [*skins around databases*](https://www.reddit.com/r/programming/comments/1a2mf7/programming_is_terriblelessons_learned_from_a/c8tjzl5) for the haters. The purpose is to provide data persistence and manipulation given a set of models that conform to [some limitations](https://github.com/fortunejs/fortune/blob/rewrite/lib/index.js#L134-L171). It is intended to be used standalone or composed within Node.js web frameworks (Express, Connect, Koa, etc).

The first thing you'll have to do is install [Node.js](https://nodejs.org/) (if you're on Linux, install `nodejs` from your package manager). You will need [Babel](http://babeljs.io) to run ES6 code:

```
$ npm install -g babel
```

*Note: if the above did not work, you will probably need root permissions, so try running it with `sudo`.*

Then install Fortune from the command-line:

```
$ npm install fortune
```

Then create an empty `index.js` file next to the `node_modules` folder, and start by importing Fortune and creating an instance:

```js
import fortune from 'fortune'

const app = fortune.create()
```

We don't need to pass any arguments to the constructor, the defaults should work. The application must have record types to be useful. Let's start with a basic example:

```js
app.defineType('user', {
  username: { type: String },
  key: { type: Buffer },
  salt: { type: Buffer },
  group: { link: 'group', inverse: 'users', isArray: true }
})

app.defineType('group', {
  name: { type: String },
  users: { link: 'user', inverse: 'group', isArray: true }
})
```

This defines a `user` record type that has a relationship to the `group` type. By default, relationships are to-one, unless `isArray` is specified. In this example, there is a many-to-many relationship between a user and a group. The `inverse` field specifies a corresponding field on the linked type, so that any update to either field will affect the other.

Transformations can be defined per record type. For the user type, it would be a good idea to store the password as a cryptographically secure key, and to hide fields when displaying the record. Transform functions accept at least two arguments, the `context` object, and the record. The record for an input transform may be the record to be created or deleted, or an updated record with updates applied.

```js
import crypto from 'crypto'

const { errors } = Fortune
const { methods } = app.dispatcher
const [ iterations, keyLength, saltLength ] =
  [ Math.pow(2, 15), Math.pow(2, 9), Math.pow(2, 6) ]

app.transformInput('user', (context, record) => {
  const { method, type } = context.request
  const { password, id } = record
  let salt, key

  if (method === methods.delete) return null

  if (method === methods.create && !password)
    throw new errors.BadRequestError(`Password must be specified.`)

  // If a password is supplied, there are asynchronous operations involved.
  return password ? new Promise((resolve, reject) =>
    // Generate a new salt.
    crypto.randomBytes(saltLength, (error, buffer) =>
    error ? reject(error) : resolve(buffer)))
  .then(buffer => {
    salt = buffer

    return new Promise((resolve, reject) =>
      // Generate secure password key.
      crypto.pbkdf2(password, salt.toString(),
        iterations, keyLength, (error, buffer) =>
        error ? reject(error) : resolve(buffer)))
  })
  .then(buffer => {
    key = buffer

    if (method === methods.create) {
      record.key = key
      record.salt = salt
      return record
    }

    return app.adapter.update(type, {
      id, replace: { key, salt }
    })
  }) : record
})

app.transformOutput('user', (context, record) => {
  // Hide sensitive fields.
  delete record.salt
  delete record.key

  return record
})
```

Input transform functions are run before anything gets persisted, so it is safe to throw errors. They may either synchronously return a value, or return a Promise. The returned/resolved value only matters for create requests. Note that the `password` field on the record is not defined in the record type. Arbitrary fields should be parsed on create and update but not persisted.

To start the application, we need to call the `start` method.

```js
import http from 'http'

const listener = fortune.net.http.bind(app)
const server = http.createServer(listener)
const port = 1337

app.start().then(() => {
  server.listen(port)
  console.log(`Server is listening on port $(port)...`)
})
```

Using Fortune with HTTP is optional, but since the built-in serializers provide HTTP functionality in conjunction with the `Fortune.net.http` module, it's easy to get started with it. The `fortune.net.http` module is a listener function that accepts a `request` and `response` object that is generated by Node.js. It needs to be [bound](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind) to the application in order to work. The reason why it needs to be bound is that the listener function refers to `this`, which should be a Fortune instance.

Making a curl request to the server:

```
$ curl -X GET -v "http://localhost:1337/"
```

The response should be the entry point, in [Micro API](http://micro-api.org/#entry-point) format. Every Micro API entity includes hyperlinks, so the API should be mostly self-discoverable.
